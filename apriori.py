#Importing the necessary basic modules for the code to run successfully
import sys
import csv
import operator

#The below function calculates powerset - all the possible subsets with set size = k
def powerset(s, k):
    x = len(s)
    powerset = []
    list = None
    for i in range(1, 1 << x):
        list = [s[j] for j in range(x) if (i & (1 << j))]
        if len(list) == k:
            powerset.append(list)

    return powerset

#The below function checks for each subset whether it is a frequent subset
def has_frequent_subset(c, L, k):
    subsets = powerset(c, k)

    for subset in subsets:

        frequent_subset = False
        for item in L:
            if set(subset) == set(item[0].split(",")):
                frequent_subset = True
                break

        if frequent_subset == False:
            return False

    return True

#The below function calculates the frequent itemsets
#Which includes the calculation of candidate and frequent itemsets
def calculate_freq_itemsets(Dataset, minimum_support, row_count):

    dataset = None
    itemset = {}

   #The below code calculates candidate itemsets
    with open(Dataset, 'r') as f:
        dataset = csv.reader(f)
        for i in dataset:
            for j in i:
                if j in itemset:
                    itemset[j.strip()] += 1
                else:
                    itemset[j.strip()] = 1

    #The below code calculates the frequent itemsets
    for item in itemset.copy():
        if itemset[item]/float(row_count) < minimum_support:
            itemset.pop(item, None)

    return sorted(itemset.items(), key=operator.itemgetter(0))

#The below function refines the association rules already generated by the generate_apriori_rules(L,k,row_count)
def generate_association_rules(itemset, minimum_confidence, row_count):

    if len(itemset) < 2:
        print("There are no association rules present for the given dataset retail")
    else:
        Dataset = str(sys.argv[1])

        print("\nThe minimum confidence threshold as given by user : ", minimum_confidence*100, "%\n")

        print("The association rules are as follows : \n")

        for k in range(1, len(itemset)):
            for pair in itemset[k]:
                for i in range(1, len(itemset[k][0][0].split(','))):
                    for item in powerset(pair[0].split(','), i):
                        item_sup = None
                        for j in itemset[i-1]:
                            if j[0] == ",".join(item):
                                item_sup = int(j[1])
                        if item_sup is not None and pair[1]/float(item_sup) >= minimum_confidence: #This line checks if the particular association rule is above the minimum confidence level
                                print(",".join(item), "=>", ",".join(list(set(pair[0].split(',')) - set(item))), "Support: ", float("{0:.2f}".format(float(item_sup)/row_count))*100, "%", "Confidence: ", float("{0:.2f}".format(pair[1]/float(item_sup)*100)), "%")

#The below function generates the association rules
def generate_apriori_rules(L, k, row_count):

    C = []
    for l1 in L:
        for l2 in L:

            first_itemlist = l1[0].split(",")
            second_itemlist = l2[0].split(",")
            i = 0
            flag = True
            while i <= k-2-1:
                if first_itemlist[i] != second_itemlist[i]:
                    flag = False
                    break
                i += 1

            if not first_itemlist[k-1-1] < second_itemlist[k-1-1]:
                flag = False

            if flag == True:
                c = sorted(set(first_itemlist) | set(second_itemlist))

                if has_frequent_subset(list(c), L, k-1):
                    C.append(",".join(list(c)))

    return C


def main():

    Dataset = str(sys.argv[1])
    minimum_support = float(sys.argv[2])
    minimum_confidence = float(sys.argv[3])

    with open(sys.argv[1], 'r') as input_file:
        lines = input_file.readlines()
        newLines = []
        for line in lines:
            newLine = line.strip(' ').split()
            newLines.append(newLine)

    with open("retail.csv", 'w') as output_file:
        file_writer = csv.writer(output_file)
        file_writer.writerows(newLines)

    Dataset = "retail.csv"

    print("The dataset is :")
    print(Dataset)
    print("The minimum support is :")
    print(minimum_support)
    print("The Minimum confidence is :")
    print(minimum_confidence)

    row_count = 0

    with open(Dataset, 'r') as f:
        dataset = csv.reader(f)
        row_count = sum(1 for row in dataset)


    #This line generates the frequent itemsets, which includes generating the candidate and frequent itemsets
    L1 = calculate_freq_itemsets(Dataset, minimum_support, row_count)
    itemset = [L1]



    k = 2

    while True:
        if not itemset[k-2]:
            break

        #This line generates all the possible apriori rules
        C = generate_apriori_rules(itemset[k-2], k, row_count)
        L = {}

        #The below code
        with open(Dataset, 'r') as f:
            dataset = csv.reader(f)
            for t in dataset:
                for c in C:
                    if set(c.split(",")).issubset(set(t)):
                        if c in L:
                            L[c] += 1
                        else:
                            L[c] = 1

        #This removes the items from the list whose support fall below the minimum_support_line
        for item in L.copy():
            if L[item]/float(row_count) < minimum_support:
                L.pop(item, None)

        itemset.append(sorted(L.items(), key=operator.itemgetter(0)))
        k += 1

    itemset.pop()
    generate_association_rules(itemset, minimum_confidence, row_count)
    print("\nThe resultant itemsets are : ")

    for k in range(1, len(itemset)):
        print("Total Number of Itemsets are : ",k)
        print("\n")

        for item in itemset[k]:
            print(item[0])
            print("with support")
            print(float("{0:.2f}".format(item[1]/float(row_count)))*100)
            print("%")


if __name__ == "__main__":
    main()